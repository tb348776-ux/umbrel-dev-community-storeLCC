version: "3.7"

services:
  app_proxy:
    environment:
      # Use a unique DNS alias to avoid collisions on Umbrel's shared Docker network.
      APP_HOST: axedgb-app
      APP_PORT: 3000

  init:
    image: alpine:3.22.1
    volumes:
      - ${APP_DATA_DIR}/data:/data
    environment:
      APPS_SUBNET: "${NETWORK_IP}/16"
      RPC_USER: "dgb"
      RPC_PASSWORD: "${APP_PASSWORD}"
      DGB_P2P_PORT: "12024"
      DGB_RPC_PORT: "14022"
      DGB_ZMQ_HASHBLOCK_PORT: "28344"
      # Miningcore requires a syntactically valid payout address at startup.
      # This is a deterministic "burn" address (no real wallet address is shipped in the repo).
      # Stratum ports default to 127.0.0.1 (see miningcore.json.template) so external mining won't work until configured.
      PAYOUT_ADDRESS: "D596YFweJQuHY1BbjazZYmAbt8jJPbKehC"
      DB_HOST: "postgres"
      DB_USER: "miningcore"
      DB_PASSWORD: "${APP_PASSWORD}"
      DB_NAME: "miningcore"
      MINDIFF: "1024"
      STARTDIFF: "1024"
      MAXDIFF_JSON: "null"
    command:
      - /bin/sh
      - -ec
      - |-
        set -eu

        apk add --no-cache envsubst curl jq postgresql-client >/dev/null

        mkdir -p /data/node /data/pool/config /data/pool/postgres /data/templates

        # Cleanup from older broken installs (a directory with the script name).
        if [ -d /data/templates/init-entrypoint.sh ]; then
          rm -rf /data/templates/init-entrypoint.sh || true
        fi

        if [ ! -f /data/node/digibyte.conf ]; then
          envsubst < /data/templates/digibyte.conf.template > /data/node/digibyte.conf
          chown -R 1000:1000 /data/node
        else
          if ! grep -q '^maxconnections=' /data/node/digibyte.conf; then
            echo "[axedgb] Adding maxconnections=64 to digibyte.conf"
            {
              printf "\n"
              printf "# AxeDGB defaults\n"
              printf "maxconnections=64\n"
            } >> /data/node/digibyte.conf
          fi
          if ! grep -q '^upnp=' /data/node/digibyte.conf; then
            echo "[axedgb] Adding upnp=1 to digibyte.conf"
            {
              printf "\n"
              printf "# AxeDGB defaults\n"
              printf "upnp=1\n"
            } >> /data/node/digibyte.conf
          fi
          if ! awk 'BEGIN{inTest=0; found=0} /^\\[test\\][[:space:]]*$/{inTest=1} /axedgb-rpc-defaults-v2/{if(!inTest) found=1} END{exit(found?0:1)}' /data/node/digibyte.conf; then
            echo "[axedgb] Adding RPC capacity defaults to digibyte.conf"
            if grep -q '^\\[test\\][[:space:]]*$' /data/node/digibyte.conf; then
              awk 'BEGIN{added=0}
                /^\\[test\\][[:space:]]*$/{if(!added){
                  print "";
                  print "# axedgb-rpc-defaults-v2";
                  print "# AxeDGB defaults (Miningcore + UI increase RPC load)";
                  print "rpcworkqueue=1024";
                  print "rpcthreads=32";
                  added=1
                }}
                {print}
              ' /data/node/digibyte.conf > /data/node/digibyte.conf.tmp && mv /data/node/digibyte.conf.tmp /data/node/digibyte.conf
            else
              {
                printf "\n"
                printf "# axedgb-rpc-defaults-v2\n"
                printf "# AxeDGB defaults (Miningcore + UI increase RPC load)\n"
                printf "rpcworkqueue=1024\n"
                printf "rpcthreads=32\n"
              } >> /data/node/digibyte.conf
            fi
          fi
          if ! grep -q 'axedgb-seeds-v1' /data/node/digibyte.conf; then
            echo "[axedgb] Adding bootstrap peers to digibyte.conf"
            {
              printf "\n"
              printf "# AxeDGB bootstrap peers (helps early IBD if DNS seeds are flaky)\n"
              printf "# axedgb-seeds-v1\n"
              printf "addnode=5.189.152.60:12024\n"
              printf "addnode=24.97.94.219:12024\n"
              printf "addnode=45.76.249.217:12024\n"
              printf "addnode=47.93.161.68:12024\n"
              printf "addnode=52.45.88.37:12024\n"
              printf "addnode=60.12.123.42:12024\n"
              printf "addnode=66.108.15.5:12024\n"
              printf "addnode=73.156.140.158:12024\n"
              printf "addnode=144.76.103.24:12024\n"
              printf "addnode=184.164.16.141:12024\n"
            } >> /data/node/digibyte.conf
          fi

          # Ensure testnet section exists so switching to testnet doesn't end up with 0 peers.
          if ! grep -q '^\\[test\\][[:space:]]*$' /data/node/digibyte.conf; then
            echo "[axedgb] Adding [test] section defaults to digibyte.conf"
            {
              printf "\n"
              printf "# Testnet settings\n"
              printf "[test]\n"
              printf "port=12026\n"
              printf "rpcport=14023\n"
              printf "rpcbind=0.0.0.0\n"
              printf "zmqpubhashblock=tcp://0.0.0.0:$$DGB_ZMQ_HASHBLOCK_PORT\n"
              printf "addnode=testnet-seed.digibyte.org:12026\n"
              printf "addnode=95.179.160.53:12026\n"
              printf "addnode=51.15.113.125:12026\n"
            } >> /data/node/digibyte.conf
          fi
        fi

        if [ ! -f /data/pool/config/miningcore.json ]; then
          envsubst < /data/templates/miningcore.json.template > /data/pool/config/miningcore.json
          chown -R 1000:1000 /data/pool/config || true
        else
          # Normalize config across upgrades (some Miningcore builds don't accept banning.manager,
          # and Miningcore currently assumes notifications exists).
          if command -v jq >/dev/null 2>&1 && jq -e '.' >/dev/null 2>&1 < /data/pool/config/miningcore.json; then
            tmp="/data/pool/config/miningcore.json.tmp"
            jq --argjson rpcport "$$DGB_RPC_PORT" '
              .notifications = (.notifications // {"enabled": false})
              | (.banning |= (if type=="object" then del(.manager) else . end))
              | (.pools |= (if type=="array" then map(
                  if type=="object" then
                    (.paymentProcessing = (.paymentProcessing // {"enabled": false}))
                    | (.blockRefreshInterval = ((.blockRefreshInterval // 500) | if . < 2000 then 2000 else . end))
                    | (.daemons = ((.daemons // []) | (if type=="array" then map(if type=="object" then (.port=$rpcport) else . end) else . end)))
                  else . end
                ) else . end))
            ' /data/pool/config/miningcore.json > "$$tmp" && mv "$$tmp" /data/pool/config/miningcore.json

            # Ensure the Scrypt pool exists when upgrading from SHA256-only configs.
            if ! jq -e '.pools[]? | select(.id=="dgb-scrypt-1")' /data/pool/config/miningcore.json >/dev/null 2>&1; then
              echo "[axedgb] Adding dgb-scrypt-1 Miningcore pool"
              base_addr="$(jq -r '.pools[]? | select(.id=="dgb-sha256-1") | .address // empty' /data/pool/config/miningcore.json | head -n 1)"
              base_diff="$(jq -r '.pools[]? | select(.id=="dgb-sha256-1") | (.ports|to_entries[0].value.difficulty // 1024)' /data/pool/config/miningcore.json | head -n 1)"
              base_mindiff="$(jq -r '.pools[]? | select(.id=="dgb-sha256-1") | (.ports|to_entries[0].value.varDiff.minDiff // 1024)' /data/pool/config/miningcore.json | head -n 1)"
              base_maxdiff_json="$(jq -c '.pools[]? | select(.id=="dgb-sha256-1") | (.ports|to_entries[0].value.varDiff.maxDiff // null)' /data/pool/config/miningcore.json | head -n 1)"
              daemons_json="$(jq -c '.pools[]? | select(.id=="dgb-sha256-1") | (.daemons // [])' /data/pool/config/miningcore.json | head -n 1)"
              if [ -z "$$daemons_json" ]; then daemons_json='[]'; fi
              if [ -z "$$base_maxdiff_json" ]; then base_maxdiff_json='null'; fi

              tmp2="/data/pool/config/miningcore.json.tmp2"
              jq --arg addr "$$base_addr" \
                 --argjson diff "$$base_diff" \
                 --argjson mindiff "$$base_mindiff" \
                 --argjson maxdiff "$$base_maxdiff_json" \
                 --argjson daemons "$$daemons_json" \
                 '
                 .pools = (.pools // []) + [{
                   "id": "dgb-scrypt-1",
                   "enabled": true,
                   "coin": "digibyte-scrypt",
                   "address": $$addr,
                   "blockRefreshInterval": 500,
                   "jobRebroadcastTimeout": 10,
                   "clientConnectionTimeout": 600,
                   "paymentProcessing": {"enabled": false},
                   "banning": {"enabled": true, "time": 600, "invalidPercent": 50, "checkThreshold": 50},
                   "ports": {
                     "3334": {
                       "listenAddress": "127.0.0.1",
                       "difficulty": $$diff,
                       "varDiff": {
                         "minDiff": $$mindiff,
                         "maxDiff": $$maxdiff,
                         "targetTime": 15,
                         "retargetTime": 90,
                         "variancePercent": 30
                       }
                     }
                   },
                   "daemons": $$daemons
                 }]
                 ' /data/pool/config/miningcore.json > "$$tmp2" && mv "$$tmp2" /data/pool/config/miningcore.json
            fi
          fi
        fi

        # Ensure Miningcore has a coins.json available at runtime.
        # Our Miningcore container expects this file next to the binary; without it, the API can crash on startup.
        if [ ! -f /data/pool/config/coins.json ]; then
          cat > /data/pool/config/coins.json <<'EOF'
        {
          "digibyte-sha256": {
            "name": "Digibyte Sha256",
            "canonicalName": "Digibyte",
            "symbol": "DGB",
            "family": "bitcoin",
            "website": "https://digibyte.org/",
            "market": "https://coinmarketcap.com/currencies/digibyte/",
            "twitter": "https://twitter.com/digibytecoin",
            "telegram": "https://t.me/DigiByteCoin",
            "discord": "",
            "coinbaseHasher": { "hash": "sha256d" },
            "headerHasher": { "hash": "sha256d" },
            "blockHasher": { "hash": "reverse", "args": [ { "hash": "sha256d" } ] },
            "blockTemplateRpcExtraParams": ["sha256d"],
            "explorerBlockLink": "https://chainz.cryptoid.info/dgb/block.dws?$$height$$.htm",
            "explorerTxLink": "https://chainz.cryptoid.info/dgb/tx.dws?{0}.htm",
            "explorerAccountLink": "https://chainz.cryptoid.info/dgb/address.dws?{0}.htm"
          },
          "digibyte-scrypt": {
            "name": "Digibyte Scrypt",
            "canonicalName": "Digibyte",
            "symbol": "DGB",
            "family": "bitcoin",
            "website": "https://digibyte.org/",
            "market": "https://coinmarketcap.com/currencies/digibyte/",
            "twitter": "https://twitter.com/digibytecoin",
            "telegram": "https://t.me/DigiByteCoin",
            "discord": "",
            "coinbaseHasher": { "hash": "sha256d" },
            "headerHasher": { "hash": "scrypt", "args": [1024, 1] },
            "blockHasher": { "hash": "reverse", "args": [ { "hash": "sha256d" } ] },
            "shareMultiplier": 65536,
            "blockTemplateRpcExtraParams": ["scrypt"],
            "explorerBlockLink": "https://chainz.cryptoid.info/dgb/block.dws?$$height$$.htm",
            "explorerTxLink": "https://chainz.cryptoid.info/dgb/tx.dws?{0}.htm",
            "explorerAccountLink": "https://chainz.cryptoid.info/dgb/address.dws?{0}.htm"
          }
        }
        EOF
          chown 1000:1000 /data/pool/config/coins.json || true
        fi

        # Ensure Miningcore DB schema exists (poolstats etc). This is safe to re-run when missing.
        export PGPASSWORD="$$DB_PASSWORD"
        echo "[axedgb] Waiting for postgres..."
        for i in $(seq 1 60); do
          if pg_isready -h "$$DB_HOST" -p 5432 -U "$$DB_USER" >/dev/null 2>&1; then
            break
          fi
          sleep 1
        done

        if ! psql -h "$$DB_HOST" -p 5432 -U "$$DB_USER" -d "$$DB_NAME" -tA -c "SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='poolstats';" 2>/dev/null | grep -q '^1$'; then
          echo "[axedgb] Initializing Miningcore database schema"
          if [ ! -f /data/templates/miningcore-createdb.sql ]; then
            echo "[axedgb] miningcore-createdb.sql missing; writing built-in schema"
            mkdir -p /data/templates
            {
              printf '%s\n' 'SET statement_timeout = 0;'
              printf '\n'
              printf '%s\n' 'CREATE TABLE shares (id BIGSERIAL PRIMARY KEY NOT NULL, poolid TEXT NOT NULL, blockheight BIGINT NOT NULL, difficulty DOUBLE PRECISION NOT NULL, networkdifficulty DOUBLE PRECISION NOT NULL, miner TEXT NOT NULL, worker TEXT, useragent TEXT, ipaddress TEXT, source TEXT, created TIMESTAMP NOT NULL);'
              printf '%s\n' 'CREATE INDEX IX_shares_poolid_created ON shares(poolid, created);'
              printf '%s\n' 'CREATE INDEX IX_shares_poolid_miner_created ON shares(poolid, miner, created);'
              printf '%s\n' 'CREATE INDEX IX_shares_poolid_miner_worker_created ON shares(poolid, miner, worker, created);'
              printf '\n'
              printf '%s\n' 'CREATE TABLE blocks (id BIGSERIAL PRIMARY KEY NOT NULL, poolid TEXT NOT NULL, blockheight BIGINT NOT NULL, networkdifficulty DOUBLE PRECISION NOT NULL, status INT NOT NULL, type INT NOT NULL, transactionconfirmationdata TEXT, miner TEXT NOT NULL, worker TEXT, effort DOUBLE PRECISION NOT NULL, rewardamount DOUBLE PRECISION NOT NULL, info TEXT, hash TEXT NOT NULL, created TIMESTAMP NOT NULL);'
              printf '%s\n' 'CREATE INDEX IX_blocks_poolid_created ON blocks(poolid, created);'
              printf '%s\n' 'CREATE INDEX IX_blocks_poolid_height ON blocks(poolid, blockheight);'
              printf '\n'
              printf '%s\n' 'CREATE TABLE balances (id BIGSERIAL PRIMARY KEY NOT NULL, poolid TEXT NOT NULL, address TEXT NOT NULL, amount DOUBLE PRECISION NOT NULL, created TIMESTAMP NOT NULL);'
              printf '%s\n' 'CREATE INDEX IX_balances_poolid_address ON balances(poolid, address);'
              printf '%s\n' 'CREATE INDEX IX_balances_poolid_created ON balances(poolid, created);'
              printf '\n'
              printf '%s\n' 'CREATE TABLE balance_changes (id BIGSERIAL PRIMARY KEY NOT NULL, poolid TEXT NOT NULL, address TEXT NOT NULL, amount DOUBLE PRECISION NOT NULL, usage TEXT, tags TEXT, created TIMESTAMP NOT NULL);'
              printf '%s\n' 'CREATE INDEX IX_balance_changes_poolid_created ON balance_changes(poolid, created);'
              printf '%s\n' 'CREATE INDEX IX_balance_changes_poolid_address_created ON balance_changes(poolid, address, created);'
              printf '\n'
              printf '%s\n' 'CREATE TABLE miner_settings (id BIGSERIAL PRIMARY KEY NOT NULL, poolid TEXT NOT NULL, address TEXT NOT NULL, paymentthreshold DOUBLE PRECISION NOT NULL, created TIMESTAMP NOT NULL);'
              printf '%s\n' 'CREATE INDEX IX_miner_settings_poolid_address ON miner_settings(poolid, address);'
              printf '\n'
              printf '%s\n' 'CREATE TABLE payments (id BIGSERIAL PRIMARY KEY NOT NULL, poolid TEXT NOT NULL, coin TEXT NOT NULL, address TEXT NOT NULL, amount DOUBLE PRECISION NOT NULL, transactionconfirmationdata TEXT, created TIMESTAMP NOT NULL);'
              printf '%s\n' 'CREATE INDEX IX_payments_poolid_created ON payments(poolid, created);'
              printf '%s\n' 'CREATE INDEX IX_payments_poolid_address_created ON payments(poolid, address, created);'
              printf '\n'
              printf '%s\n' 'CREATE TABLE poolstats (id BIGSERIAL PRIMARY KEY NOT NULL, poolid TEXT NOT NULL, connectedminers INT NOT NULL, poolhashrate DOUBLE PRECISION NOT NULL, networkhashrate DOUBLE PRECISION NOT NULL, networkdifficulty DOUBLE PRECISION NOT NULL, lastnetworkblocktime TIMESTAMP, blockheight BIGINT NOT NULL, connectedpeers INT NOT NULL, sharespersecond INT NOT NULL, created TIMESTAMP NOT NULL);'
              printf '%s\n' 'CREATE INDEX IX_poolstats_poolid_created ON poolstats(poolid, created);'
              printf '\n'
              printf '%s\n' 'CREATE TABLE minerstats (id BIGSERIAL PRIMARY KEY NOT NULL, poolid TEXT NOT NULL, miner TEXT NOT NULL, hashrate DOUBLE PRECISION NOT NULL, sharespersecond INT NOT NULL, created TIMESTAMP NOT NULL);'
              printf '%s\n' 'CREATE INDEX IX_minerstats_poolid_created ON minerstats(poolid, created);'
              printf '%s\n' 'CREATE INDEX IX_minerstats_poolid_miner_created ON minerstats(poolid, miner, created);'
              printf '\n'
            } > /data/templates/miningcore-createdb.sql
          fi
          psql -v ON_ERROR_STOP=1 -h "$$DB_HOST" -p 5432 -U "$$DB_USER" -d "$$DB_NAME" < /data/templates/miningcore-createdb.sql >/dev/null
        fi

        # Seed an initial poolstats row so Miningcore's API does not error before the first stats tick.
        if psql -h "$$DB_HOST" -p 5432 -U "$$DB_USER" -d "$$DB_NAME" -tA -c "SELECT COUNT(*) FROM poolstats WHERE poolid='dgb-sha256-1';" 2>/dev/null | grep -q '^0$'; then
          echo "[axedgb] Seeding initial poolstats row"
          psql -v ON_ERROR_STOP=1 -h "$$DB_HOST" -p 5432 -U "$$DB_USER" -d "$$DB_NAME" -c "INSERT INTO poolstats (poolid, connectedminers, poolhashrate, networkhashrate, networkdifficulty, lastnetworkblocktime, blockheight, connectedpeers, sharespersecond, created) VALUES ('dgb-sha256-1', 0, 0, 0, 0, NULL, 0, 0, 0, NOW());" >/dev/null
        fi

  dgbd:
    image: ghcr.io/willitmod/digibyte:8.22.2
    user: "1000:1000"
    restart: unless-stopped
    stop_grace_period: 15m30s
    depends_on:
      init:
        condition: service_completed_successfully
    ports:
      - "12024:12024/tcp" # P2P
      - "12026:12026/tcp" # P2P (testnet)
    volumes:
      - ${APP_DATA_DIR}/data/node:/data
      - ${APP_DATA_DIR}/data/templates/dgb-entrypoint.sh:/dgb-entrypoint.sh:ro
    entrypoint: ["/bin/sh", "/dgb-entrypoint.sh"]
    healthcheck:
      # Treat "warming up" states as healthy so Umbrel doesn't hide the UI while syncing.
      test:
        [
          "CMD-SHELL",
          "digibyte-cli -datadir=/data getblockchaininfo >/dev/null 2>&1 || digibyte-cli -datadir=/data getblockchaininfo 2>&1 | grep -qE 'Loading block index|Rewinding blocks|Verifying blocks|Loading wallet'",
        ]
      interval: 30s
      timeout: 10s
      retries: 20
      start_period: 2m

  postgres:
    image: postgres:16-alpine
    restart: unless-stopped
    shm_size: "256mb"
    environment:
      POSTGRES_USER: "miningcore"
      POSTGRES_PASSWORD: "${APP_PASSWORD}"
      POSTGRES_DB: "miningcore"
    volumes:
      - ${APP_DATA_DIR}/data/pool/postgres:/var/lib/postgresql/data

  miningcore:
    image: ghcr.io/willitmod/miningcore:axedgb-0.8.10-r1
    restart: unless-stopped
    depends_on:
      - postgres
      - dgbd
      - init
    stop_grace_period: 30s
    ports:
      - "5678:3333/tcp" # Stratum v1 (SHA256)
      - "5679:3334/tcp" # Stratum v1 (Scrypt)
    volumes:
      - ${APP_DATA_DIR}/data/pool/config/miningcore.json:/app/config.json:ro
      - ${APP_DATA_DIR}/data/pool/config/coins.json:/app/coins.json:ro

  app:
    image: ghcr.io/willitmod/axedgb-app-umbrel-dev:0.8.10
    user: "1000:1000"
    restart: on-failure
    stop_grace_period: 30s
    # Keep the UI up even if the node/pool is still starting.
    networks:
      default:
        aliases:
          - axedgb-app
    volumes:
      - ${APP_DATA_DIR}/data:/data
    environment:
      DGB_RPC_HOST: "dgbd"
      DGB_RPC_PORT: "14022"
      DGB_RPC_USER: "dgb"
      DGB_RPC_PASS: "${APP_PASSWORD}"
      MININGCORE_API_URL: "http://miningcore:4000"
      MININGCORE_POOL_ID: "dgb-sha256-1"
      MININGCORE_POOL_IDS: "sha256:dgb-sha256-1,scrypt:dgb-scrypt-1"
      STRATUM_PORTS: "sha256:5678,scrypt:5679"
      MININGCORE_CONF_PATH: "/data/pool/config/miningcore.json"
      APP_CHANNEL: "ALPHA"
      DGB_IMAGE: "ghcr.io/willitmod/digibyte:8.22.2"
      MININGCORE_IMAGE: "ghcr.io/willitmod/miningcore:axedgb-0.8.10-r1"
      POSTGRES_IMAGE: "postgres:16-alpine"
      STATIC_DIR: "/app/static"
